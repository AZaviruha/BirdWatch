@(tweets: Seq[Tweet])(implicit request: RequestHeader)

@mainEmpty("Tweets!") {
  <script src="@routes.Assets.at("javascripts/d3.js")" type="text/javascript"></script>
  <script src="@routes.Assets.at("javascripts/d3.layout.cloud.js")" type="text/javascript"></script>
  <link rel="stylesheet" media="screen" href="@routes.Assets.at("stylesheets/dw.css")">
  
  <script type="text/javascript">
  $(function() {
    var ws = new WebSocket("@routes.Twitter.tweetFeed.webSocketURL()")

    // Overall viewmodel for this screen, along with initial state
    var TweetsViewModel = function() {
      this.tweets = ko.observableArray();
    }
    var viewModel = new TweetsViewModel()
    ko.applyBindings(viewModel);
    
    // d3 word cloud
    var lastUpdated = new Date().getTime() - 2000;
    var fill = d3.scale.category20b();
    var w = 700, h = 500;
    var maxEntries = 250
    
    var words = [{key: "", value: 0}, {key: "", value: 0}, {key: "", value: 0}, 
      {key: "", value: 0}, {key: "", value: 0}, {key: "", value: 0}, 
      {key: "", value: 0}, {key: "", value: 0}, {key: "", value: 0}, 
      {key: "", value: 0}, {key: "", value: 0}, {key: "", value: 0}, 
      {key: "", value: 0}, {key: "", value: 0}, {key: "", value: 0}, 
      {key: "", value: 0}, {key: "", value: 0}, {key: "", value: 0}];
    
    //var words = [],
    var   max,
        scale = 1,
        complete = 0,
        keyword = "",
        tags,
        fontSize,
        maxLength = 30,
        fetcher = "http://search.twitter.com/search.json?rpp=100&q={word}",
        statusText = d3.select("#status");
        
    var layout = d3.layout.cloud()
        .timeInterval(1)
        .size([w, h])
        .fontSize(function(d) { return fontSize(+d.value); })
        .text(function(d) { return d.key; })
        .on("end", draw);

    var svg = d3.select("#wordcloud").append("svg")
        .attr("width", w)
        .attr("height", h);

    var background = svg.append("g"),
        vis = svg.append("g")
        .attr("transform", "translate(" + [w >> 1, h >> 1] + ")");

    function generate() {
      layout
        .font("Impact")
        .spiral("archimedean");
      fontSize = d3.scale["log"]().range([10, 85]);
      
      if (tags.length) fontSize.domain([+tags[tags.length - 1].value || 1, +tags[0].value]);
      complete = 0;
      words = [];
      layout.stop().words(tags.slice(0, max = Math.min(tags.length, maxEntries))).start();
      lastUpdated = new Date().getTime();
    }

    function draw(data, bounds) {
      statusText.style("display", "none");
      scale = bounds ? Math.min(
          w / Math.abs(bounds[1].x - w / 2),
          w / Math.abs(bounds[0].x - w / 2),
          h / Math.abs(bounds[1].y - h / 2),
          h / Math.abs(bounds[0].y - h / 2)) / 2 : 1;
      words = data;
      var text = vis.selectAll("text")
          .data(words, function(d) { return d.text.toLowerCase(); });
      text.transition()
          .duration(1000)
          .attr("transform", function(d) { return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")"; })
          .style("font-size", function(d) { return d.size + "px"; });
      text.enter().append("text")
          .attr("text-anchor", "middle")
          .attr("transform", function(d) { return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")"; })
          .style("font-size", function(d) { return d.size + "px"; })
          .on("click", function(d) {
            load(d.text);
          })
          .style("opacity", 1e-6)
        .transition()
          .duration(1000)
          .style("opacity", 1);
      text.style("font-family", function(d) { return d.font; })
          .style("fill", function(d) { return fill(d.text.toLowerCase()); })
          .text(function(d) { return d.text; });
      var exitGroup = background.append("g")
          .attr("transform", vis.attr("transform"));
      var exitGroupNode = exitGroup.node();
      text.exit().each(function() {
        exitGroupNode.appendChild(this);
      });
      exitGroup.transition()
          .duration(1000)
          .style("opacity", 1e-6)
          .remove();
      vis.transition()
          .delay(1000)
          .duration(750)
          .attr("transform", "translate(" + [w >> 1, h >> 1] + ")scale(" + scale + ")");
    }
    
    var barChartContainer;
    
    function renderBarChart() {
      
      var key = function(d) { return d.key;
      };

    var valueLabelWidth = 40; // space reserved for value labels (right)
    var barHeight = 20; // height of one bar
    var barLabelWidth = 150; // space reserved for bar labels
    var barLabelPadding = 5; // padding between bar and bar labels (left)
    var gridLabelHeight = 18; // space reserved for gridline labels
    var gridChartOffset = 3; // space between start of grid and first bar
    var maxBarWidth = 420; // width of the bar with the max value

    // accessor functions 
    var barLabel = function(d) { return d.key; };
    var barValue = function(d) { return parseFloat(d.value); };

    // sorting
    var sortedData = words.sort(function(a, b) {
     return d3.descending(barValue(a), barValue(b));
    }); 
   
    // scales
    var yScale = d3.scale.ordinal().domain(d3.range(0, sortedData.length)).rangeBands([0, sortedData.length * barHeight]);
    var y = function(d, i) { return yScale(i); };
    var yText = function(d, i) { return y(d, i) + yScale.rangeBand() / 2; };
    var xScale = d3.scale.linear().domain([0, d3.max(sortedData, barValue)]).range([0, maxBarWidth]);
    // svg container element
     chart = d3.select('#wordBars').append("svg")
      .attr('width', maxBarWidth + barLabelWidth + valueLabelWidth)
      .attr('height', gridLabelHeight + gridChartOffset + sortedData.length * barHeight);
    // grid line labels
    gridContainer = chart.append('g')
      .attr('transform', 'translate(' + barLabelWidth + ',' + gridLabelHeight + ')'); 
    gridContainer.selectAll("text").data(xScale.ticks(10)).enter().append("text")
      .attr("x", xScale)
      .attr("dy", -3)
      .attr("text-anchor", "middle")
      .text(String);
    // vertical grid lines
    gridContainer.selectAll("line").data(xScale.ticks(10)).enter().append("line")
      .attr("x1", xScale)
      .attr("x2", xScale)
      .attr("y1", 0)
      .attr("y2", yScale.rangeExtent()[1] + gridChartOffset)
      .style("stroke", "#ccc");
    // bar labels
    labelsContainer = chart.append('g')
      .attr('transform', 'translate(' + (barLabelWidth - barLabelPadding) + ',' + (gridLabelHeight + gridChartOffset) + ')'); 
    labelsContainer.selectAll('text').data(sortedData).enter().append('text')
      .attr('y', yText)
      .attr('stroke', 'none')
      .attr('fill', 'black')
      .attr("dy", ".35em") // vertical-align: middle
      .attr('text-anchor', 'end')
      .text(barLabel);
    // bars
     barsContainer = chart.append('g')
      .attr('transform', 'translate(' + barLabelWidth + ',' + (gridLabelHeight + gridChartOffset) + ')'); 
    barsContainer.selectAll("rect").data(sortedData).enter().append("rect")
      .attr('y', y)
      .attr('height', yScale.rangeBand())
      .attr('width', function(d) { return xScale(barValue(d)); })
      .attr('stroke', 'white')
      .attr('fill', 'steelblue');
    // bar value labels
    barsContainer.selectAll("text").data(sortedData).enter().append("text")
      .attr("x", function(d) { return xScale(barValue(d)); })
      .attr("y", yText)
      .attr("dx", 3) // padding-left
      .attr("dy", ".35em") // vertical-align: middle
      .attr("text-anchor", "start") // text-align: right
      .attr("fill", "black")
      .attr("stroke", "none")
      .text(function(d) { return d3.round(barValue(d), 2); });
    // start line
    barsContainer.append("line")
      .attr("y1", -gridChartOffset)
      .attr("y2", yScale.rangeExtent()[1] + gridChartOffset)
      .style("stroke", "#000");

    }
    renderBarChart();
    
    function redrawBarChart() {
      
      var key = function(d) { return d.key;
      };
      
      // accessor functions 
      var barLabel = function(d) { return d.key; };
      var barValue = function(d) { return parseFloat(d.value); };

      // var sortedData = words.sort(function(a, b) {
      //  return d3.descending(barValue(a), barValue(b));
      // });
      
      var sortedData = words.sort(function(a, b) {
          if(barValue(b) < barValue(a)) return -1;
          if(barValue(b) > barValue(a)) return 1;
          if(barLabel(b) < barLabel(a)) return -1;
          if(barLabel(b) > barLabel(a)) return 1;            
          return 0;
      });
      
       
      
      //console.log(sortedData)
      
      var valueLabelWidth = 40; // space reserved for value labels (right)
      var barHeight = 20; // height of one bar
      var barLabelWidth = 100; // space reserved for bar labels
      var barLabelPadding = 5; // padding between bar and bar labels (left)
      var gridLabelHeight = 18; // space reserved for gridline labels
      var gridChartOffset = 3; // space between start of grid and first bar
      var maxBarWidth = 420; // width of the bar with the max value
      
      var yScale = d3.scale.ordinal().domain(d3.range(0, sortedData.length)).rangeBands([0, sortedData.length * barHeight]);
      var y = function(d, i) { return yScale(i); };
      var yText = function(d, i) { return y(d, i) + yScale.rangeBand() / 2; };
      var xScale = d3.scale.linear().domain([0, d3.max(sortedData, barValue)]).range([0, maxBarWidth]);
      
      // Updateâ€¦
      var rect = chart.selectAll("rect")
          .data(sortedData);
        
      rect.transition()
        .attr('y', y)
        .attr('height', yScale.rangeBand())
        .attr('width', function(d) { return xScale(barValue(d)); })
          
      barsContainer.selectAll("text").data(sortedData)  
        .transition()
        .attr("x", function(d) { return xScale(barValue(d)); })
        .attr("y", yText)
        .attr("dx", 3) // padding-left
        .attr("dy", ".35em") // vertical-align: middle
        .attr("text-anchor", "start") // text-align: right
        .attr("fill", "black")
        .attr("stroke", "none")
        .text(function(d) { return d3.round(barValue(d), 2); });
            
      labelsContainer.selectAll('text').data(sortedData)  
        .transition()
        .attr('y', yText)
        .attr('stroke', 'none')
        .attr('fill', 'black')
        .attr("dy", ".35em") // vertical-align: middle
        .attr('text-anchor', 'end')
        .text(barLabel);
        
      gridContainer.selectAll("text").data(xScale.ticks(10))  
        .transition()
        .attr("x", xScale)
        .attr("dy", -3)
        .attr("text-anchor", "middle")
        .text(String);
        
      gridContainer.selectAll("line").data(xScale.ticks(10))
          .attr("x1", xScale)
          .attr("x2", xScale)
          .attr("y1", 0)
          .attr("y2", yScale.rangeExtent()[1] + gridChartOffset)
          .style("stroke", "#ccc");
            

    }
    
    ws.onmessage = function(msg){
      var data = JSON.parse(msg.data)
      //viewModel.tweets(data.tweetList)
      
      viewModel.tweets.unshift(data.tweetList[0])
      
      if(viewModel.tweets.length > 0) { viewModel.tweets.pop() }
      
      
      tags = data.topWords;
      //redrawBarChart();
      
      if ( (new Date().getTime() - lastUpdated) > 500) {
        redrawBarChart();
      }
      //console.log(data)
      //console.log("tags.size " + tags.length + " words.size: " + words.length);
      if ( (new Date().getTime() - lastUpdated) > 5000) {
        generate();
      }      

    }
  })
  </script>
  
  <div id="header"><h1>BirdWatch</h1></div>

  <div id="wordcloud"></div>

  <div id="wordBars"></div>

  <div id="tweets">
    <ul data-bind="foreach: tweets">
      <li><div class="tweetlist"><span><img data-bind="attr: { src: img_url }" /></span><div class="screen_name" data-bind="text: screen_name"></div>&nbsp;&nbsp;&nbsp;&nbsp;<div class="timeInterval" data-bind="text: timeAgo"></div><br /><div class="tweettext"><span data-bind="text: text"><br /></span></div></div></li>
    </ul>
  </div>
    
  @tweets.map { tweet =>
  <!--ul>
    <li><span>@tweet.screen_name</span>: @tweet.text - @tweet.created_at
  </ul-->
  } 

}